# ********************** COPYRIGHT INTEL CORPORATION ***********************
#
# THE SOFTWARE CONTAINED IN THIS FILE IS CONFIDENTIAL AND PROPRIETARY
# TO INTEL CORPORATION. THIS PRINTOUT MAY NOT BE PHOTOCOPIED,
# REPRODUCED, OR USED IN ANY MANNER WITHOUT THE EXPRESSED WRITTEN
# CONSENT OF INTEL CORPORATION. ALL LOCAL, STATE, AND FEDERAL
# LAWS RELATING TO COPYRIGHTED MATERIAL APPLY.
#
# Copyright (c), Intel Corporation
#
# ********************** COPYRIGHT INTEL CORPORATION ***********************


# C plugin class
import os

import inspect
import json
import jsonpath_rw_ext as jp

from edatasheets_creator.document.jsondatasheet import JsonDataSheet
from edatasheets_creator.functions import t
from edatasheets_creator.constants import serializationconstants
from edatasheets_creator.constants import ctypes
from edatasheets_creator.constants import spreadsheettypes
from edatasheets_creator.plugins.spreadsheetmap import SpreadsheetMap
from edatasheets_creator.logger.exceptionlogger import ExceptionLogger
from edatasheets_creator.utility.path_utilities import validateRealPath


class Plugin:
    """
    C file plugin class that implements c file generation from a XLSX spreadsheet
    """

    def __init__(self):
        """
        Class initialization
        """

        self._worksheetSectionIndexWritten = False  # used in multisection worksheets to indicate that index values are already written
        self._indexOnRow = -1
        self._indexOnCol = -1

    def __repr__(self):
        """
            Returns a name for the class

        Returns:
            string : class name
        """
        return __name__ + '.' + inspect.currentframe().f_code.co_name

    def process(self, inputFileName, outputFileName, mapFileName=""):
        """

        Main logic method for creating a c file

        Args:
            inputFileName (PosixPath): Input .json file
            outputFileName (PosixPath): Output file name
            mapFileName (PosixPath): Map file to guide parser if applicable
        """
        try:
            msg = t("ClangFile Plugin is loaded")
            ExceptionLogger.logInformation(__name__, msg)

            # Validate if the input files exists on the system as they are required
            if (not validateRealPath(inputFileName)):
                # Input file does not exist
                ExceptionLogger.logInformation(__name__, "", t("\n Input file does not exist"))
                print()
                return

            if (not validateRealPath(mapFileName)):
                # Map file does not exist
                ExceptionLogger.logInformation(__name__, "", t("\n Map file does not exist"))
                print()
                return

            fileDetails = os.path.splitext(inputFileName)
            self._fileName = fileDetails[0] + "." + serializationconstants.JSON_FILE_EXTENSION

            self._outputFileName = fileDetails[0] + "." + serializationconstants.C_NAME

            self._mapFileName = mapFileName

            # Load map file
            map = SpreadsheetMap(self._mapFileName)

            self.createCFile(self._fileName, self._outputFileName, map)

        except FileNotFoundError as fnf:
            ExceptionLogger.logError(__name__, "", fnf)

        except Exception as e:
            ExceptionLogger.logError(__name__, "", e)

    def createCFile(self, inputFileName, outputFileName, map):
        """

         Main method for generating and writing to a c file

         Args:
            inputFileName (PosixPath): Input .json file
            outputFileName (PosixPath): Output header file
            mapFileName (PosixPath): Map file to guide parser if applicable
        """

        try:
            # Defining all the needed variables
            self._inputFileName = inputFileName
            self._outputFileName = outputFileName

            # open the passed in file and load it as an object
            with open(self._inputFileName) as inputFile:
                inputContents = json.load(inputFile)

            # open the output file so that we can write to it
            with open(self._outputFileName, "w") as outfile:
                outfile.write("/* AUTO-GENERATED by clangfile.py, do not edit! */\n")

                names = []
                states = []
                directions = []
                drains = []
                capabilities = []
                muxConfig = []

                # get the sheet names
                sheetName = map.getSheetNames()

                # getting the worksheet name from the map
                worksheetName = str(JsonDataSheet.generateValidJsonFieldName(sheetName[0]))

                # getting the necessary column names
                keysList = []
                for fields in jp.match("$." + worksheetName + "[*]", inputContents):
                    keysList.append(list(fields.keys()))

                # splitting up the keys so that we are able to use them
                splitUpKeys = str(keysList[0]).split("'")

                # getting all the rows in each of the necessary column names
                # these values are hard coded based on the map values, change if necessary
                for name in jp.match("$." + worksheetName + "[*]." + splitUpKeys[3], inputContents):
                    names.append(name)
                for mux in jp.match("$." + worksheetName + "[*]." + splitUpKeys[5], inputContents):
                    muxConfig.append(mux)
                for state in jp.match("$." + worksheetName + "[*]." + splitUpKeys[7], inputContents):
                    states.append(state)
                for direction in jp.match("$." + worksheetName + "[*]." + splitUpKeys[11], inputContents):
                    directions.append(direction)
                for drain in jp.match("$." + worksheetName + "[*]." + splitUpKeys[9], inputContents):
                    drains.append(drain)
                for capability in jp.match("$." + worksheetName + "[*]." + splitUpKeys[13], inputContents):
                    capabilities.append(capability)

                # getting everything uppercase
                names = self.toUpperCase(names)
                states = self.toUpperCase(states)
                directions = self.toUpperCase(directions)
                drains = self.toUpperCase(drains)
                capabilities = self.toUpperCase(capabilities)

                # changing the outputs for directions to get one uniform way to parse the data
                # for i in range(len(directions)):
                #    if(directions[i].lower() == "output"):
                #        pass
                #    elif(directions[i].lower() == "input" ):
                #        pass
                #    else:
                #        directions[i] = " "

                # getting the interrupt capability in the correct format
                index = 0
                for c in capabilities:
                    if (c.lower() != spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL):
                        capabilities[index] = ctypes.C_GPIO_FIELD + "_" + ctypes.C_INT_FIELD + "_" + ctypes.C_EDGE_FIELD + "_" + c
                    index += 1

                # getting the drains in the correct format
                index = 0
                for d in drains:
                    if (d.lower() != spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL):
                        d = drains[index].replace(" ", "_")
                        drains[index] = ctypes.C_GPIO_FIELD + "_" + d
                    index += 1

                # identifying necessary variables
                combinedStates = []
                namesToRemove = []
                index = 0
                combinedOutputs = zip(directions, states)

                # putting the states and directions together in the correct order
                for element1, element2 in combinedOutputs:
                    if (element1.lower() == spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL):
                        namesToRemove.append(index)
                        pass
                    elif (element1 != " " and element2.lower() == spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL):
                        combinedStates.append(ctypes.C_GPIO_FIELD + "_" + element1)
                    else:
                        combinedStates.append(ctypes.C_GPIO_FIELD + "_" + element1 + "_" + element2)
                    index = index + 1

                # removing the names that do not have a direction associated with it
                for index in namesToRemove:
                    names[index] = "None"
                    muxConfig[index] = "None"
                    drains[index] = "None"
                    capabilities[index] = "None"

                for index in namesToRemove:
                    muxConfig[index] = "None"

                finalMux = [value for value in muxConfig if value != "None"]
                finalNames = [value for value in names if value != "None"]
                finalDrains = [value for value in drains if value != "None"]
                finalCap = [value for value in capabilities if value != "None"]
                # print(finalMux)

                # zipping all the necessary data pieces together
                combinedFinalOutputs = zip(finalNames, combinedStates, finalDrains, finalCap, finalMux)

                # hard-coded the name of the file, NEED TO CHANGE!!!
                outfile.write("struct gpio_ec_config mecc1501_cfg[] = {\n")

                # writing to the file in the specified format, CHANGE IF NECESSARY
                for element1, element2, element3, element4, element5 in combinedFinalOutputs:
                    if (element5 != ctypes.C_GPIO_FIELD):
                        continue
                    elif (element3.lower() == spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL and element4.lower() == spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL and element5 == ctypes.C_GPIO_FIELD):
                        outfile.write("\t{  " + element1 + ",\t" + element2 + "},\n")
                    elif (element4.lower() == spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL and element5 == ctypes.C_GPIO_FIELD):
                        outfile.write("\t{  " + element1 + ",\t" + element2 + " | " + element3 + "},\n")
                    elif (element3.lower() == spreadsheettypes.SPREADSHEET_MAP_EMPTY_VAL and element5 == ctypes.C_GPIO_FIELD):
                        outfile.write("\t{  " + element1 + ",\t" + element2 + " | " + element4 + "},\n")
                    else:
                        outfile.write("\t{  " + element1 + ",\t" + element2 + " | " + element3 + "  | " + element4 + "},\n")

                # ending the file
                outfile.write("\t};")

        except FileNotFoundError as fnf:
            ExceptionLogger.logError(__name__, "", fnf)

        except Exception as e:
            ExceptionLogger.logError(__name__, "", e)

    def toUpperCase(self, list):
        self._list = list
        for item in range(len(self._list)):
            self._list[item] = self._list[item].upper()

        return self._list
